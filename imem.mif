-- null
DEPTH = 4096;
WIDTH = 32;

ADDRESS_RADIX = DEC;
DATA_RADIX = BIN;

CONTENT
BEGIN
    -- nop
0000 : 00000000000000000000000000000000;
    -- addi $1, $0, 0  	    	# ins1 r1 = 0
0001 : 00101000010000000000000000000000;
    -- addi $2, $0, -1			# ins2 r2 = -1
0002 : 00101000100000011111111111111111;
    -- addi $3, $0, 0			# ins3 r3 = 0
0003 : 00101000110000000000000000000000;
    -- addi $4, $0, 5			# ins4 r4 = 5
0004 : 00101001000000000000000000000101;
    -- sll $1, $1, 4			# ins5 r1 << 4. r1 change as F, FF, FFF, FFFF, FFFFF, FFFFFF
0005 : 00000000010000100000001000010000;
    -- addi $1, $1, 15			# ins6 r1 += 15
0006 : 00101000010000100000000000001111;
    -- sll $2, $2, 4			# ins7 r2 << 4. r2 change as -1, -2, -4, -8, -16, ..., -16777216
0007 : 00000000100001000000001000010000;
    -- addi $3, $3, 1			# ins8 r3 += 1.
0008 : 00101000110001100000000000000001;
    -- blt $4, $3, 1			# ins9 if (r3 > 5) break
0009 : 00110001000001100000000000000001;
    -- j 5				# ins10 for (r3 < 5) $3 += 1, r1 change, r2 change
0010 : 00001000000000000000000000000101;
    -- addi $5, $0, 127		# ins11 r5 = 127 (1111111)
0011 : 00101001010000000000000001111111;
    -- addi $6, $0, 1			# ins12 r6 = 1
0012 : 00101001100000000000000000000001;
    -- sll $6, $6, 31			# ins13 r6 << 32, r6 = -2147483648
0013 : 00000001100011000000111110010000;
    -- sll $1, $1, 7			# ins14 r1 << 7 = 2147483520
0014 : 00000000010000100000001110010000;
    -- or $1, $1, $5			# ins15 r1 = r1 | r5 = 2147483647
0015 : 00000000010000100101000000001100;
    -- and $2, $2, $6			# ins16 r2 = r2 & r6 = -2147483648
0016 : 00000000100001000110000000001000;
    -- addi $6, $0, 1			# ins17 r6 = 1
0017 : 00101001100000000000000000000001;
    -- add $31, $1, $5			# ins18 r31 = r1+r5 (Overflow) -> r30 = 1
0018 : 00000111110000100101000000000000;
    -- bex 21				# ins19 r30 != 0 -> jump to 21
0019 : 10110000000000000000000000010101;
    -- j 10000				# ins20 if bex failed, jump to no instruction (have problem in bex)
0020 : 00001000000000000010011100010000;
    -- setx 0				# ins21 r30 = 0
0021 : 10101000000000000000000000000000;
    -- bne $30, $0, 10000		# ins22 r30 != 0, jump to no instruction (have problem in setx)
0022 : 00010111100000000010011100010000;
    -- addi $6, $0, 2			# ins23 r6 = 2
0023 : 00101001100000000000000000000010;
    -- addi $31, $1, 20		# ins24 r31 = r1+20 (Overflow) -> r30 = 2
0024 : 00101111110000100000000000010100;
    -- bex 27				# ins25 r30 != 0 -> jump to 27
0025 : 10110000000000000000000000011011;
    -- j 10000				# ins26 if bex failed, jump to no instruction (have problem in bex)
0026 : 00001000000000000010011100010000;
    -- setx 0				# ins27 r30 = 0
0027 : 10101000000000000000000000000000;
    -- bne $30, $0, 10000		# ins28 r30 != 0, jump to no instruction (have problem in setx)
0028 : 00010111100000000010011100010000;
    -- addi $6, $0, 3			# ins29 r6 = 3
0029 : 00101001100000000000000000000011;
    -- sub $31, $2, $5			# ins30 r31 = r2-r5 (Overflow) -> r30 = 3
0030 : 00000111110001000101000000000100;
    -- bex 33				# ins31 r30 != 0 -> jump to 33
0031 : 10110000000000000000000000100001;
    -- j 10000				# ins32 if bex failed, jump to no instruction (have problem in bex)
0032 : 00001000000000000010011100010000;
    -- setx 0				# ins33 r30 = 0
0033 : 10101000000000000000000000000000;
    -- bne $30, $0, 10000		# ins34 r30 != 0, jump to no instruction (have problem in setx)
0034 : 00010111100000000010011100010000;
    -- addi $6, $0, 1			# ins35 r6 = 1
0035 : 00101001100000000000000000000001;
    -- addi $3, $0, 10			# ins36 r3 = 10
0036 : 00101000110000000000000000001010;
    -- addi $4, $0, 10			# ins37 r4 = 10
0037 : 00101001000000000000000000001010;
    -- sra $1, $1, 20			# ins38 r1 = 2047
0038 : 00000000010000100000101000010100;
    -- jal 49				# ins39 jump to save word function
0039 : 00011000000000000000000000110001;
    -- blt $4, $3, 7			# ins40 if(r3 > r4(10)) break
0040 : 00110001000001100000000000000111;
    -- lw $7, 0($6)			# ins41 load word value 1, 3, 7, 15, ...., 1023, 2047 in [1024, 512, ..., 8, 4, 2, 1]
0041 : 01000001110011000000000000000000;
    -- bne $7, $1, 10000		# ins42 if ($7 != $1), jump to no instruction (have problem in lw, sll, sra or blt)
0042 : 00010001110000100010011100010000;
    -- sll $1, $1, 1			# ins43 
0043 : 00000000010000100000000010010000;
    -- addi $1, $1, 1			# ins44 r1 = 3, 7, 15, .... 2047 
0044 : 00101000010000100000000000000001;
    -- addi $3, $3, 1			# ins45 r3 += 1
0045 : 00101000110001100000000000000001;
    -- sra $6, $6, 1			# ins46 r6 >> 1, r6 = 2048, 1024, ..., 1
0046 : 00000001100011000000000010010100;
    -- j 40				# ins47 for (r3 < 10) load word
0047 : 00001000000000000000000000101000;
    -- j 56				# ins48 jump to final function-> clear all data
0048 : 00001000000000000000000000111000;
    -- blt $3, $0, 5			# ins49 if(r3 < 0) break
0049 : 00110000110000000000000000000101;
    -- sw $1, 0($6)			# ins50 save word to number 2047, 1023, 511, 255, 127, 63, 31, 15, 7, 3, 1 in [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
0050 : 00111000010011000000000000000000;
    -- addi $3, $3, -1			# ins51 r3 -= 1
0051 : 00101000110001111111111111111111;
    -- sll $6, $6, 1			# ins52 r6 << 1, r6 = 1, 2, 4, 8, 16, .. 1024
0052 : 00000001100011000000000010010000;
    -- sra $1, $1, 1			# ins53 r1 >> 1, r1 = 2047, 1023, 511, 255, 127, ...., 1
0053 : 00000000010000100000000010010100;
    -- j 49				# ins54 (for loop) 
0054 : 00001000000000000000000000110001;
    -- jr $31				# ins55 return to main function
0055 : 00100111110000000000000000000000;
    -- and $1, $1, $0			# ins56 clear r1 = 0
0056 : 00000000010000100000000000001000;
    -- and $2, $2, $0			# ins57 clear r2 = 0
0057 : 00000000100001000000000000001000;
    -- and $3, $3, $0			# ins58 clear r3 = 0
0058 : 00000000110001100000000000001000;
    -- and $4, $4, $0			# ins59 clear r4 = 0
0059 : 00000001000010000000000000001000;
    -- and $5, $5, $0			# ins60 clear r5 = 0
0060 : 00000001010010100000000000001000;
    -- and $6, $6, $0			# ins61 clear r6 = 0
0061 : 00000001100011000000000000001000;
    -- and $7, $7, $0			# ins62 clear r7 = 0
0062 : 00000001110011100000000000001000;
    -- and $30, $30, $0		# ins63 clear r30 = 0
0063 : 00000111101111000000000000001000;
    -- and $31, $31, $0		# ins64 clear r31 = 0
0064 : 00000111111111100000000000001000;
    -- nop
0065 : 00000000000000000000000000000000;
    -- nop
0066 : 00000000000000000000000000000000;
[0067 .. 4095] : 00000000000000000000000000000000;
END;
